{"ast":null,"code":"import _parseInt from \"@babel/runtime-corejs2/core-js/parse-int\";\nimport _JSON$stringify from \"@babel/runtime-corejs2/core-js/json/stringify\";\nimport _parseFloat from \"@babel/runtime-corejs2/core-js/parse-float\";\n\n/**\n * Extracts and returns float value from a string.\n *\n * @param {string} string String\n * @return {any}\n */\nexport var getFloatVal = function getFloatVal(string) {\n  var floatValue = string && string.match(/[+-]?\\d+(\\.\\d+)?/g)[0];\n  return null !== floatValue ? _parseFloat(_parseFloat(floatValue).toFixed(2)) : '';\n};\n/**\n * Create a new product object.\n *\n * @param {Object} product Product\n * @param {Integer} productPrice Product Price\n * @param {Integer} qty Quantity\n * @return {{image: *, productId: *, totalPrice: number, price: *, qty: *, name: *}}\n */\n\nexport var createNewProduct = function createNewProduct(product, productPrice, qty) {\n  return {\n    productId: product.productId,\n    image: product.image,\n    name: product.name,\n    price: productPrice,\n    qty: qty,\n    totalPrice: _parseFloat((productPrice * qty).toFixed(2))\n  };\n};\n/**\n * Add first product.\n *\n * @param {Object} product Product\n * @return {{totalProductsCount: number, totalProductsPrice: any, products: Array}}\n */\n\nexport var addFirstProduct = function addFirstProduct(product) {\n  var productPrice = getFloatVal(product.price);\n  var newCart = {\n    products: [],\n    totalProductsCount: 1,\n    totalProductsPrice: _parseFloat(productPrice.toFixed(2))\n  };\n  var newProduct = createNewProduct(product, productPrice, 1);\n  newCart.products.push(newProduct);\n  localStorage.setItem('wpd-cart', _JSON$stringify(newCart));\n  return newCart;\n};\n/**\n * Get updated products array\n * Update the product if it exists else,\n * add the new product to existing cart,\n *\n * @param {Object} existingProductsInCart Existing product in cart\n * @param {Object} product Product\n * @param {Integer} qtyToBeAdded Quantity\n * @param {Integer} newQty New qty of the product (optional)\n * @return {*[]}\n */\n\nexport var getUpdatedProducts = function getUpdatedProducts(existingProductsInCart, product, qtyToBeAdded) {\n  var newQty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  // Check if the product already exits in the cart.\n  var productExitsIndex = isProductInCart(existingProductsInCart, product.productId); // If product exits ( index of that product found in the array ), update the product quantity and totalPrice\n\n  if (-1 < productExitsIndex) {\n    var updatedProducts = existingProductsInCart;\n    var updatedProduct = updatedProducts[productExitsIndex]; // If have new qty of the product available, set that else add the qtyToBeAdded\n\n    updatedProduct.qty = newQty ? _parseInt(newQty) : _parseInt(updatedProduct.qty + qtyToBeAdded);\n    updatedProduct.totalPrice = _parseFloat((updatedProduct.price * updatedProduct.qty).toFixed(2));\n    return updatedProducts;\n  } else {\n    // If product not found push the new product to the existing product array.\n    var productPrice = getFloatVal(product.price);\n    var newProduct = createNewProduct(product, productPrice, qtyToBeAdded);\n    existingProductsInCart.push(newProduct);\n    return existingProductsInCart;\n  }\n};\n/**\n * Updates the existing cart with new item.\n *\n * @param {Object} existingCart Existing Cart.\n * @param {Object} product Product.\n * @param {Integer} qtyToBeAdded Quantity.\n * @param {Integer} newQty New Qty to be updated.\n * @return {{totalProductsCount: *, totalProductsPrice: *, products: *}}\n */\n\nexport var updateCart = function updateCart(existingCart, product, qtyToBeAdded) {\n  var newQty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var updatedProducts = getUpdatedProducts(existingCart.products, product, qtyToBeAdded, newQty);\n\n  var addPrice = function addPrice(total, item) {\n    total.totalPrice += item.totalPrice;\n    total.qty += item.qty;\n    return total;\n  }; // Loop through the updated product array and add the totalPrice of each item to get the totalPrice\n\n\n  var total = updatedProducts.reduce(addPrice, {\n    totalPrice: 0,\n    qty: 0\n  });\n  var updatedCart = {\n    products: updatedProducts,\n    totalProductsCount: _parseInt(total.qty),\n    totalProductsPrice: _parseFloat(total.totalPrice)\n  };\n  localStorage.setItem('wpd-cart', _JSON$stringify(updatedCart));\n  return updatedCart;\n};\n/**\n * Returns index of the product if it exists.\n *\n * @param {Object} existingProductsInCart Existing Products.\n * @param {Integer} productId Product id.\n * @return {number | *} Index Returns -1 if product does not exist in the array, index number otherwise\n */\n\nvar isProductInCart = function isProductInCart(existingProductsInCart, productId) {\n  var returnItemThatExits = function returnItemThatExits(item, index) {\n    if (productId === item.productId) {\n      return item;\n    }\n  }; // This new array will only contain the product which is matched.\n\n\n  var newArray = existingProductsInCart.filter(returnItemThatExits);\n  return existingProductsInCart.indexOf(newArray[0]);\n};\n/**\n * Remove Item from the cart.\n *\n * @param {Integer} productId Product Id.\n * @return {any | string} Updated cart\n */\n\n\nexport var removeItemFromCart = function removeItemFromCart(productId) {\n  var existingCart = localStorage.getItem('wpd-cart');\n  existingCart = JSON.parse(existingCart); // If there is only one item in the cart, delete the cart.\n\n  if (1 === existingCart.products.length) {\n    localStorage.removeItem('wpd-cart');\n    return null;\n  } // Check if the product already exits in the cart.\n\n\n  var productExitsIndex = isProductInCart(existingCart.products, productId); // If product to be removed exits\n\n  if (-1 < productExitsIndex) {\n    var productTobeRemoved = existingCart.products[productExitsIndex];\n    var qtyToBeRemovedFromTotal = productTobeRemoved.qty;\n    var priceToBeDeductedFromTotal = productTobeRemoved.totalPrice; // Remove that product from the array and update the total price and total quantity of the cart\n\n    var updatedCart = existingCart;\n    updatedCart.products.splice(productExitsIndex, 1);\n    updatedCart.totalProductsCount = updatedCart.totalProductsCount - qtyToBeRemovedFromTotal;\n    updatedCart.totalProductsPrice = updatedCart.totalProductsPrice - priceToBeDeductedFromTotal;\n    localStorage.setItem('wpd-cart', _JSON$stringify(updatedCart));\n    return updatedCart;\n  } else {\n    return existingCart;\n  }\n};","map":{"version":3,"sources":["/Users/kukreja/Projects/Freelance/injiri-ecommerce/util/cart-functions.js"],"names":["getFloatVal","string","floatValue","match","toFixed","createNewProduct","product","productPrice","qty","productId","image","name","price","totalPrice","addFirstProduct","newCart","products","totalProductsCount","totalProductsPrice","newProduct","push","localStorage","setItem","getUpdatedProducts","existingProductsInCart","qtyToBeAdded","newQty","productExitsIndex","isProductInCart","updatedProducts","updatedProduct","updateCart","existingCart","addPrice","total","item","reduce","updatedCart","returnItemThatExits","index","newArray","filter","indexOf","removeItemFromCart","getItem","JSON","parse","length","removeItem","productTobeRemoved","qtyToBeRemovedFromTotal","priceToBeDeductedFromTotal","splice"],"mappings":"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","sourcesContent":["/**\n * Extracts and returns float value from a string.\n *\n * @param {string} string String\n * @return {any}\n */\nexport const getFloatVal = ( string ) => {\n\n\tlet floatValue = string && string.match( /[+-]?\\d+(\\.\\d+)?/g )[0];\n\treturn ( null !== floatValue ) ? parseFloat( parseFloat( floatValue ).toFixed( 2 ) ) : '';\n\n};\n\n/**\n * Create a new product object.\n *\n * @param {Object} product Product\n * @param {Integer} productPrice Product Price\n * @param {Integer} qty Quantity\n * @return {{image: *, productId: *, totalPrice: number, price: *, qty: *, name: *}}\n */\nexport const createNewProduct = ( product, productPrice, qty ) => {\n\n\treturn  {\n\t\tproductId: product.productId,\n\t\timage: product.image,\n\t\tname: product.name,\n\t\tprice: productPrice,\n\t\tqty,\n\t\ttotalPrice: parseFloat( ( productPrice * qty ).toFixed( 2 ) )\n\t};\n\n};\n\n/**\n * Add first product.\n *\n * @param {Object} product Product\n * @return {{totalProductsCount: number, totalProductsPrice: any, products: Array}}\n */\nexport const addFirstProduct = ( product ) => {\n\n\tlet productPrice = getFloatVal( product.price );\n\n\tlet newCart = {\n\t\tproducts: [],\n\t\ttotalProductsCount: 1,\n\t\ttotalProductsPrice: parseFloat( productPrice.toFixed( 2 ) )\n\t};\n\n\tconst newProduct = createNewProduct( product, productPrice, 1 );\n\tnewCart.products.push( newProduct );\n\n\tlocalStorage.setItem( 'wpd-cart', JSON.stringify( newCart ) );\n\n\treturn newCart;\n};\n\n/**\n * Get updated products array\n * Update the product if it exists else,\n * add the new product to existing cart,\n *\n * @param {Object} existingProductsInCart Existing product in cart\n * @param {Object} product Product\n * @param {Integer} qtyToBeAdded Quantity\n * @param {Integer} newQty New qty of the product (optional)\n * @return {*[]}\n */\nexport const getUpdatedProducts = ( existingProductsInCart, product, qtyToBeAdded, newQty = false ) => {\n\n\t// Check if the product already exits in the cart.\n\tconst productExitsIndex = isProductInCart( existingProductsInCart, product.productId );\n\n\t// If product exits ( index of that product found in the array ), update the product quantity and totalPrice\n\tif ( -1 < productExitsIndex ) {\n\t\tlet updatedProducts = existingProductsInCart;\n\t\tlet updatedProduct = updatedProducts[ productExitsIndex ];\n\n\t\t// If have new qty of the product available, set that else add the qtyToBeAdded\n\t\tupdatedProduct.qty = ( newQty ) ? parseInt( newQty ) : parseInt( updatedProduct.qty + qtyToBeAdded );\n\t\tupdatedProduct.totalPrice = parseFloat( ( updatedProduct.price * updatedProduct.qty ).toFixed( 2 ) );\n\n\t\treturn  updatedProducts;\n\t} else {\n\n\t\t// If product not found push the new product to the existing product array.\n\t\tlet productPrice = getFloatVal( product.price );\n\t\tconst newProduct = createNewProduct( product, productPrice, qtyToBeAdded );\n\t\texistingProductsInCart.push( newProduct );\n\n\t\treturn existingProductsInCart;\n\t}\n};\n\n/**\n * Updates the existing cart with new item.\n *\n * @param {Object} existingCart Existing Cart.\n * @param {Object} product Product.\n * @param {Integer} qtyToBeAdded Quantity.\n * @param {Integer} newQty New Qty to be updated.\n * @return {{totalProductsCount: *, totalProductsPrice: *, products: *}}\n */\nexport const updateCart = ( existingCart, product, qtyToBeAdded, newQty = false  ) => {\n\n\tconst updatedProducts = getUpdatedProducts( existingCart.products , product, qtyToBeAdded, newQty );\n\n\tconst addPrice = (total, item) => {\n\t\ttotal.totalPrice += item.totalPrice;\n\t\ttotal.qty += item.qty;\n\n\t\treturn total;\n\t};\n\n\t// Loop through the updated product array and add the totalPrice of each item to get the totalPrice\n\tlet total = updatedProducts.reduce( addPrice, { totalPrice: 0, qty: 0 } );\n\n\tconst updatedCart = {\n\t\tproducts: updatedProducts,\n\t\ttotalProductsCount: parseInt( total.qty ),\n\t\ttotalProductsPrice: parseFloat( total.totalPrice )\n\t};\n\n\tlocalStorage.setItem( 'wpd-cart', JSON.stringify( updatedCart ) );\n\n\treturn updatedCart;\n};\n\n/**\n * Returns index of the product if it exists.\n *\n * @param {Object} existingProductsInCart Existing Products.\n * @param {Integer} productId Product id.\n * @return {number | *} Index Returns -1 if product does not exist in the array, index number otherwise\n */\nconst isProductInCart = ( existingProductsInCart, productId ) => {\n\n\tconst returnItemThatExits = ( item, index ) => {\n\t\tif ( productId === item.productId ) {\n\t\t\treturn item;\n\t\t}\n\t};\n\n\t// This new array will only contain the product which is matched.\n\tconst newArray = existingProductsInCart.filter( returnItemThatExits );\n\n\treturn existingProductsInCart.indexOf( newArray[0] );\n};\n\n/**\n * Remove Item from the cart.\n *\n * @param {Integer} productId Product Id.\n * @return {any | string} Updated cart\n */\nexport const removeItemFromCart = ( productId ) => {\n\n\tlet existingCart = localStorage.getItem( 'wpd-cart' );\n\texistingCart = JSON.parse( existingCart );\n\n\t// If there is only one item in the cart, delete the cart.\n\tif ( 1 === existingCart.products.length ) {\n\n\t\tlocalStorage.removeItem( 'wpd-cart' );\n\t\treturn null;\n\n\t}\n\n\t// Check if the product already exits in the cart.\n\tconst productExitsIndex = isProductInCart( existingCart.products, productId );\n\n\t// If product to be removed exits\n\tif ( -1 < productExitsIndex ) {\n\n\t\tconst productTobeRemoved = existingCart.products[ productExitsIndex ];\n\t\tconst qtyToBeRemovedFromTotal = productTobeRemoved.qty;\n\t\tconst priceToBeDeductedFromTotal = productTobeRemoved.totalPrice;\n\n\t\t// Remove that product from the array and update the total price and total quantity of the cart\n\t\tlet updatedCart = existingCart;\n\t\t\tupdatedCart.products.splice( productExitsIndex, 1 );\n\t\t\tupdatedCart.totalProductsCount = updatedCart.totalProductsCount - qtyToBeRemovedFromTotal;\n\t\t\tupdatedCart.totalProductsPrice = updatedCart.totalProductsPrice - priceToBeDeductedFromTotal;\n\n\t\tlocalStorage.setItem( 'wpd-cart', JSON.stringify( updatedCart ) );\n\t\treturn updatedCart;\n\n\t} else {\n\t\treturn existingCart;\n\t}\n};\n"]},"metadata":{},"sourceType":"module"}